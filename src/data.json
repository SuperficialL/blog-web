{
    "article_title": [
    "利用CSS3自定义浏览器滚动条",
    "Flask(5) - 重定向",
    "Flask(4) - url_for",
    "Flask(3) - URL传参",
    "Flask(2) - debug模式设置",
    "Flask(1) - 初步使用",
    "ElementUI Select组件使用",
    "Celery初使用报错:ValueError not enough values to unpack (expected 3, got 0)",
    "博客详情页如何实现查询分类下所有文章并排除当前文章",
    "解决linux下pip install mysqlclient出现报错mysql_config",
    "VMWare安装VMWare Tools",
    "django发表文章时主动推送文章到百度",
    "django自定义用户认证",
    "django实现JWT登录",
    "Gird布局",
    "个人博客搭建三(前端页面展示)",
    "个人博客搭建二(数据库结构设计)",
    "个人博客搭建一(创建应用)",
    "django把SQLite数据库的数据导入到MySQL数据库中",
    "Python虚拟环境的安装",
    "Python获取本机IP地址",
    "git常用命令",
    "在django中添加sitemap",
    "箭头函数",
    "var,let和const的区别",
    "假设高度已知,左右宽度固定,中间自适应的几种方案",
    "文本超出隐藏",
    "pycharm配置scss文件",
    "前端的几个重要知识点"
    ],
    "article_body": [
    "我们都知道,浏览器自带的滚动条样式太丑,要美化滚动条就需要自定义滚动条样式,可以用`js`来模拟滚动条,但这样要大量的兼容处理,比较麻烦,CSS3也可以实现自定义滚动条,好像只支持`webkit`内核的浏览器 ```css /*滚动条整体样式*/ ::-webkit-scrollbar { width: 6px; height: 1px; } /*滚动条滑块*/ ::-webkit-scrollbar-thumb { border-radius: 10px; background-color: rgba(0, 0, 255, 0.5); box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); } /*滚动条轨道*/ ::-webkit-scrollbar-track { -webkit-box-shadow: inset 0 0 1px rgba(0, 0, 0, 0); box-shadow: inset 0 0 1px rgba(0, 0, 0, 0); border-radius: 10px; background: #ccc; } ```",
    "### 重定向 分为永久性重定向和暂时性重定向 **永久性重定向**:多用于旧网址被废弃,要转到一个新网址确保用户可以访问.`http`状态码:`301`,比如`www.jingdong.com`会重定向到`www.jd.com` **暂时性重定向**:页面的暂时新跳转,比如用户访问一个需要权限的网址,如果用户没有登录,将重定向到登录页面.`http`状态码:`302` ### flask中使用重定向: `flask`中有个函数`redirect`,可以重定向到指定的页面 ```python from flask import url_for,redirect @app.route('/') def index(): # 首页 name = request.args.get('name') if name: return u'您的用户名是：%s' % name else: # 跳转页面 return redirect(url_for('login')) @app.route('/login/') def login(): # 登录 return u'这是登录页面' ``` 当我们访问首页时,如果没有通过查询字符串(?query_string=value)传入`name`参数,页面将会重定向到到`login`",
    "前面的学习中,我们都是通过url进入的与之相对应的视图函数,现在有一个问题,如果我们知道了视图函数，要怎么找到url呢？这时候我们就需要url_for反转函数了。它通过把视图函数反转成路由地址 ### url_for的基本使用 ```python from flask import url_for @app.route('/') def index(): return 'Hello World!' @app.route('/detail/') def detail(): return url_for('index') ``` 当我们访问路由`detail`路由时,页面返回视图函数`index`的路由地址`/`,使用`url_for`有一个很大的好处,就是以后如果我们修改了路由,只要视图函数名字没有变,`url_for`反转的路由地址也会变更,而不用我们去修改代码 ### url_for的参数传递 我们已经来接的`url_for`的基本使用,但现在又有一个新的问题,那就是视图函数中的参数怎么传递呢? `url_for`的源码就有写到参数 ```python def url_for(endpoint, **values): ... ``` 第一个参数`endpoint`也就代表着视图函数的名字 第二个参数`**values`,传入的参数必须以键值对的形式 ```python @app.route('/detail/<int:article_id>') def detail(article_id): # url_for中传递的参数需要和视图函数中的参数名保持一致 return url_for('detail', article_id=article_id) ``` 当我们访问`/detail/1`时,页面上也会返回相对应的路由`/detail/1/`",
    "### URL与视图函数的映射 url与视图函数的映射是通过@app.route()装饰器实现的,而route中的参数表示路由路径 ### 路由 ```python @app.route('/') def hello_world(): return 'Hello World!' ``` 这是项目自带的根路由,访问`/`路由时,页面会返回Hello World! 如果要访问文章列表只需要在写一个视图函数 ```python @app.route('/list/') def hello_world(): return 'Article List!' @app.route('/list/') def hello_world(): return 'Article List!' ``` 这2种方法都可以访问,但为什么会存在2种方法呢?官网上给出了合理的解释 `/list/`尾部有一个斜杠，看起来就如同一个文件夹。访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，帮你在尾部加上一个斜杠。 `list` 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。 ### 参数传递 通过把 URL 的一部分标记为 <variable_name> 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 <converter:variable_name> ，可以 选择性的加上一个转换器，为变量指定规则 |路径类型|解释| | :------------: | :------------: | |string|(缺省值)接受任何不包含斜杠的文本| |int|接受正整数| |float|接受正浮点数| |path|类似 string ，但可以包含斜杠 |uuid|接受 UUID 字符串| ```python @app.route('/user/<username>') def show_user_profile(username): return 'User %s' % username # 不写类型,默认为string类型,接收所有字符串(不包括斜杠) @app.route('/post/<int:post_id>') def show_post(post_id): return 'Post %d' % post_id # 只接受整形类型,传递其它类型会报404 @app.route('/path/<path:subpath>') def show_subpath(subpath): return 'Subpath %s' % subpath # 接收的数据类型和string类似,都是任意字符串,但path可以接收路径,也就是说包含斜杠 @app.route('/user/<uuid:user_id>') def user(user_id): return 'User %s' % user_id # 只接受uuid类型(唯一的一串字符),防止信息泄露 ``` 还有一种参数传递的方法,通过查询字符串的方式,是通过前端表单的name属性来传递,flask通过request接收 ```python from flask import request @app.route('/search/') def index(): keyword = request.args.get('wd') return 'wd:%keyword' % keyword ``` 访问地址:`http://127.0.0.1:5000/search/?wd=flask`",
    "### 设置调试模式的原因 1. 如果开启了DEBUG模式,在代码中如果抛出异常,在浏览器页面中可以看到具体的错误信息,方便调试 2. 如果修改了代码只需要保存后,flask会自动重新加载程序,而不用重新运行 当我们运行新创建的flask项目时,控制台打印: ```python * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) ``` 让我们来看看控制台的信息 - 环境: 生产 - 警告: 这是一个开发服务器,请不要在生产环境中使用,请改用WSGI服务器 - 调试模式: 关闭 - 运行在127.0.0.1:5000端口(按CTRL+C退出) 它告诉我们调试模式没有开启,那么如何开启呢? #### 开启debug模式 开启debug模式有三种方法: 1. `app.debug = True`(直接在应用对象上设置) 2. `app.run()`方法中传递一个`debug=True`的参数 3. `app.config.update(DEBUG=True)` 4. `app.config.from_object(config)` ```python # 第一种 # 只需要在项目中实例的Flask类下添加这行代码 app.debug = True # 第二种 # 通过参数传递给开发服务器传递debug参数 if __name__ == '__main__': app.run(debug=False) # 第三种 # 通过配置参数设置DEBUG,这里的DEBUG是大写 app.config.update(DEBUG=True) # 第四种 # config.py # 新建configs.py文件,并写入DEBUG=True,这里的DEBUG是大写 DEBUG = True # app.py # 然后在项目中import刚刚写的配置文件,然后通过from_object导入配置 import config app.config.from_object(configs) ``` 开启debug模式后,重新运行程序,以后我们再修改了代码,程序都会立即重新加载,而不用每次重新运行项目,大大方便了我们的开发",
    "### 安装flask 如果使用的`windows`首先要安装[python环境](https://www.python.org/ 'python环境'){:target='_blank'} ```python pip install flask ``` 这里我使用的是PyCharm Professional直接创建创建一个名为`demo`的flask项目,这会花费一点时间,pycharm会帮我们安装flask所必须要的包,等待创建完成即可,创建完成后目录会会有三个文件夹, static, templates,venv,还有一个app.py文件 1. static: 用来存放所有静态文件 2. templates: 用来存放所有模板页面 3. venv: 所有的python包都会安装到这里(如果你创建项目的时候只修改了项目名字) ### 运行flask应用 ```python #!/usr/bin/env python # -*- coding: utf-8 -*- from flask import Flask # 从flask中导入Flask类 app = Flask(__name__) # 创建flask对象,并传递一个__name__参数 # __name__参数的作用: 可以规定模板和静态文件的查找路径 # @app.route('/') 装饰器 表示将url中的'/'映射到hello_world视图函数上 @app.route('/') def hello_world(): return 'Hello World!' if __name__ == '__main__': # 如果这个文件作为一个主文件运行,那么就会执行app.run()方法 # run()是flask自带的开发阶段的测试服务器, app.run() ```",
    "当select值为对象类型时，`option`要拿到指定的`value`,就需要提供一个`value-key`作为唯一性标识,`option`的value不需要绑定指定的`value`,只需要绑定对象 ```vue <template> <el-select v-model='postForm.tags' value-key='name' multiple filterable allow-create default-first-option placeholder='请选择文章标签'> <!-- 这里value-key绑定的是name属性,取值就之后去键为name的value --> <el-option v-for='(item,index) in tags' :key='index' :label='item.name' :value='item'> </el-option> <!-- 这里label绑定的是要显示的键,value绑定的是对象 --> </el-select> </template> <script> export default { data() { return { tags: [{ id: 1, name: 'HTML' }, { id: 2, name: 'CSS' }, { id: 3, name: 'JavaScript' }], value: [] } } } </script> ``` 这里的`postForm.tags`是后台创传递过来的标签数据,`data`中的`tags`不是真实的,为了直观的看到,自己写的,以上内容摘自我的个人博客",
    "在我初步使用`celery`时,出现了问题,在这记录自己碰到的问题, 我所使用的的开发环境 系统, 编辑工具, 1. `windows 7`64位 2. `PyCharm 2018.3.2 (Professional Edition)` 3. `Celery 4.3.0` 执行简单的任务队列时报错 ```python Traceback (most recent call last): File 'd:\\python37\\lib\\site-packages\\billiard\\pool.py', line 358, in workloop result = (True, prepare_result(fun(*args, **kwargs))) File 'd:\\python37\\lib\\site-packages\\celery\\app\\trace.py', line 544, in _fast_trace_task tasks, accept, hostname = _loc ValueError: not enough values to unpack (expected 3, got 0) ``` 解决办法: 1 安装`eventlet` ```python pip install eventlet ``` 执行celery命令时 `celery -A yours-module worker -l INFO -P eventlet` 2 切换`celery4.x+`为`celery3.1.24` ```python pip uninstall celery4.x+ pip install celery==3.1.24 ``` 3 在创建Celery实例之前设置`FORKED_BY_MULTIPROCESSING` ```python import os os.environ.setdefault（'FORKED_BY_MULTIPROCESSING'，'1'） app = Celery('celery_name') ``` celery4.x+已经不支持`windows`,如果想在`windows`上使用上面2种办法,原文来自[CSDN作者地址](https://blog.csdn.net/qq_30242609/article/details/79047660) `github`中的`celery`项目中的[issues](https://github.com/celery/celery/issues/4178 'issues')上也有提到",
    "当一个用户在看你的博客文章时，他（她）还想看看相关类型的文章，还要排除当前文章，并且不能包含当前文章，如何实现呢? 这里我用到了`django`的`tamplate_tags`,如果没有了解过模板标签,请到[官网](https://docs.djangoproject.com/en/2.2/howto/custom-template-tags/#custom-template-tags-and-filters '官网')自行了解 在`blog`应用下创建`tamplate_tags`包(不是py文件,包含一个`__init__.py`) ```django from django import template from blog.models import Article,Tag register = template.Library() @register.simple_tag def get_recommend_article(article): ''' 获取相关文章，排除自己 :param article: 是当前文章实例对象 :return: 返回一个加工后的列表 ''' tags = article.tags.all() # 通过外键获取到所有的标签 article_list = [] for tag in tags: for post in tag.article_set.filter(status='p'): # 遍历每一个标签下的文章并添加到新的列表中(status是发表/草稿的状态) if post != article: article_list.append(post) return article_list ``` 然后在博客详情页加载模板标签有可以使用了 ```html {% load_blog_tags %} <!-- 行首添加加载标签(可能要重启服务器) --> {% get_recommend_article article as article_list %} <!-- 使用时添加这个(article是详情页的文章实例对象) --> {% for article in article_list %} {% endfor %} ``` ```",
    "确认MySQL环境安装`mysql -V`,出现MySQL版本表示已经安装,出现`Not Found`表示没有安装,如果没有安装执行安装命令 ```shell sudo apt-get install mysql-server mysql-client ``` 还需要安装 sudo apt-get install libmysqlclient-dev python3-dev 然后 pip install mysqlclient就不会报错找不到'mysql_config'了",
    "### VMWare安装VMWare Tools > 作为一个开发者，linux系统是必须要会使用的，我的电脑是windows，那么如何在电脑上安装linux系统呢？ 这里就需要一个虚拟化软件，我使用的是VMWare，通过它来创建linux环境，linux系统我使用的是[乌班图桌面版](https://www.ubuntu.com/download/desktop '乌班图')，安装完系统后，使用过程中，发现系统卡顿，这时我们就需要安装`VMWare Tools`来解决 首先启动Ubuntu系统，然后如下图所示： ![](/media/editor/vmware-tools_20190510192110147246.png) 点击安装VMWare Tools(这里我安装了，所以显示重新安装) 1. 这时桌面上会出现一个名为VMware Tools光盘图标 2. 双击进入上面的光盘，在终端下将其中以.tar.gz后缀结尾的压缩包复制到某个目录(这里我复制到了tmp目录下) ```shell cp VMWare-tools-xxxx.tar.gz /tmp ``` 3. 进入到tmp目录,对压缩包进行解压 ```shell tar zxvf VMWare-tools-xxxx.tar.gz ``` 4. 解压完成后，会创建一个vmware-tools-distrib文件夹，进入运行安装程序 ```shell cd vmware-tools-distrib ./vmware-install.pl ``` 5. 安装过程中会，有需要手动输入的地方，可以不管，直接回车，知道安装完成。",
    "当我们写了一遍文章后如何让百度蜘蛛知道并来爬取我们的文章呢? 这里就需要我们主动提交数据链接到百度资源了 ### 推送数据到百度站点 在`Article`模型中新增`push`方法 ```django def push(self): '''推送到百度''' if self.status == 'p': # 当状态为发表时才发送推送请求 import requests # http://data.zz.baidu.com/site/index 站点管理中的链接提交接口 url = 'http://data.zz.baidu.com/urls?site=yours site&token=yours token' headers = { 'Content-Type': 'text/plain' } article_list = list() article_list.append('yous site/path/%s.html' % (self.pk)) data = '\n'.join(article_list) req = requests.post(url, headers=headers, data=data) res = req.json() print(res, '响应数据') ```",
    "django默认后台登录只能通过用户名登录,如果想要通过用户名或者邮箱登录,那就需要自定义后台验证了 在自定义的用户模型(Accounts)中新建`backends.py` ```django from django.contrib.auth.backends import ModelBackend from django.db.models import Q from django.contrib.auth import get_user_model from django.contrib.auth.models import Permission User = get_user_model() class CustomBackend(ModelBackend): '''自定义后台验证''' def authenticate(self, request, username=None, password=None, **kwargs): # 重写authenticate方法 user = User.objects.filter(Q(username=username) | Q(email=username)).first() if user: if user.check_password(password): return user return None ``` 在项目中的`settings.py`文件中增加自定义认证引用路径 ```django # 增加自定义后台验证路径 AUTHENTICATION_BACKENDS = ( 'accounts.backends.CustomBackend', # django.contrib.auth.backends.ModelBackend # 注释的是django自带的后台认证,这里修改为自己写的路径 ) ``` [参考文档](https://docs.djangoproject.com/zh-hans/2.2/topics/auth/customizing/ '参考文档'){:targat=_blank}",
    "在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们不再使用Session认证机制，而使用Json Web Token认证机制。 ##### 安装django-rest-framework `pip install djangorestframework djangorestframework-jwt` 在`settings.py- -> INSTALL-APP`中添加 ```django INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', ] ``` 同时还要执行迁移脚本命令,`rest_framework.authtoken`会帮我们生成一张`token`表 ```django python manage.py makemigrations python manage.py migrate ``` 在同文件夹下的`urls.py`中添加 ```django from rest_framework_jwt.views import obtain_jwt_token urlpatterns = [ re_path(r'^login/', obtain_jwt_token) ] ``` 运行服务器,打开本地服务器,请求地址`http://127.0.0.1/login` 输入账号密码,会返回生成的Token ![登录](/media/editor/login_20190503132734817568.png '登录')",
    "Grid 布局是 CSS 中最强大的布局系统。与 flexbox 的一维布局系统不同，Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于 父元素 (成为 Grid Container 网格容器)和其 子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid(网格) 布局。 Gird通过将元素的父级设置`display: grid`,来声明这是一个grid容器,来转化为网格布局。 #### 容器属性(Grid Container) ```css display: grid || inline-grid; // 声明一个容器,块状||内联 grid-template-columns: 25% 25% 25% 25%; // 定义列，有多少个参数就多少列,参数之间用逗号隔开 grid-template-rows: 25% 100px auto; // 定义行，有多少个参数就多少行,参数之间用逗号隔开 grid-column-gap // 列间距 grid-column-gap // 行间距 justify-items:start | end | center | stretch(默认); // 水平方向对齐,左对齐|右对齐|居中|填充 align-items: start | end | center | stretch; // 垂直方向对齐,顶部对齐|底部对齐|居中|填充 justify-content: start | end | center | stretch | space-around | space-between | space-evenly; // 整个容器水平对齐 align-content: start | end | center | stretch | space-around | space-between | space-evenly; // 整个容器垂直对齐 ``` #### 单元格属性 ```css grid-column-start grid-column-end grid-row-start grid-row-end ```",
    "django的强大就在于他自带后台管理系统,当然界面嘛,比较不符合我的审美,未来会考虑自定义后台界面,现阶段暂时先不管 ### 创建超超级管理员并登陆后台 执行命令`python manage.py createsuperuser` 这时会要求输入用户名,邮箱,密码,以及确认密码,依次输入即可,当然,如果你的大密码输入过于简单,可能会报错,密码设置相对复杂一点!我们就可以登录后台了 运行`python manage.py runserver` 然后使用刚才创建的账号密码登录后台发表文章 ### 编写首页视图 视图这里使用fbv模式,后面会修改为cbv模式 ```python ```",
    "一个网站,最重要的部分就是数据库的设计,在django就需要设计数据库模型,模型当中每一个属性都对应一个数据库表的字段 - 我的博客灵感来自于[轩陌的博客](https://www.xuanmo.xin '轩陌大大的博客'),他的博客页面好看,所以参考他的多一些. 在创建的`blog`App应用中打开`models.py` ### 导航栏以及分类模型 创建导航栏,导航栏的设计我是这样设计的,一个一级栏目下有零个或多个二级栏目,涉及到了一对多,当然如果对一对多不熟悉的话可以去看[django官网](https://docs.djangoproject.com/en/2.2/ref/models/fields/#foreignkey 'django官网'){:target=_blank} ```python class Navigation(models.Model): '''导航分类''' name = models.CharField('导航名',max_length=100) index = models.IntegerField(default=999,verbose_name='分类排序') class Meta: verbose_name = '导航分类' verbose_name_plural = verbose_name def __str__(self): return self.name class Category(models.Model): '''子文章分类''' name = models.CharField('分类名', max_length=50) navigation = models.ForeignKey(Navigation, on_delete=models.CASCADE, verbose_name='分类导航') class Meta: verbose_name = '文章分类' verbose_name_plural = verbose_name def __str__(self): return self.name ``` ### 标签模型 标签所需要的字段不需要很多 ```python class Tag(models.Model): '''文章标签''' name = models.CharField('文章标签',max_length=100) class Meta: verbose_name = '文章标签' verbose_name_plural = verbose_name def __str__(self): return self.name ``` ### 文章模型 这个模型需要的字段就比较多了,这里我使用了mdeditor富文本编辑器,所以写了重写了save方法,新增加了三个方法viewed,next_article和prev_article ```python from django.contrib.auth import get_user_model User = get_user_model class Article(models.Model): '''文章''' DEFAULT_IMG = '/static/images/python.jpg' title = models.CharField('标题', max_length=70) excerpt = models.TextField('摘要', max_length=200, blank=True) category = models.ForeignKey(Category, on_delete=models.CASCADE, verbose_name='分类', null=True) # 使用外键关联分类表与分类是一对多关系 tags = models.ManyToManyField(Tag, verbose_name='标签', blank=True) # 使用外键关联标签表与标签是多对多关系 img = models.ImageField(upload_to='article_img/%Y/%m/%d/', verbose_name='文章图片',default=DEFAULT_IMG) body = md_models.MDTextField(verbose_name='作者') user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='作者') views = models.PositiveIntegerField(verbose_name='阅读量', default=0) tui = models.ForeignKey(Tui, on_delete=models.DO_NOTHING, verbose_name='推荐位', null=True) created_time = models.DateTimeField(verbose_name='发表时间', auto_now_add=True) modified_time = models.DateTimeField(verbose_name='修改时间', auto_now=True) def save(self, *args, **kwargs): self.body = markdown.markdown(self.body.replace('\r\n','\n'), extensions=[ 'markdown.extensions.extra', 'markdown.extensions.codehilite', 'markdown.extensions.toc', ]) super(Article, self).save(*args, **kwargs) def viewed(self): # 访问量加一 self.views += 1 self.save(update_fields=['views']) def next_article(self): # 下一篇 return Article.objects.filter(id__gt=self.id).order_by('id').first() def prev_article(self): # 上一篇 return Article.objects.filter(id__lt=self.id).order_by('id').last() class Meta: verbose_name = '文章' verbose_name_plural = verbose_name def __str__(self): return self.title ``` ### 友情链接 一个博客怎么能没有好友呢!所有我写了这个,当好友多了之后,页面可能变得不那么美观,所有写了控制首页是否展示的方法,也可能有的好友网站过期了,没有了,就有了友情链接是否有效 ```python class Link(models.Model): '''友情链接''' name = models.CharField('链接名称', max_length=40) link_url = models.URLField('网址', max_length=100) is_active = models.BooleanField('是否有效', default=True) is_show = models.BooleanField('是否首页展示', default=False) def active_to_false(self): self.is_active = False self.save(update_fields=['is_active']) def show_to_false(self): self.is_show = True self.save(update_fields=['is_show']) def __str__(self): return self.name class Meta: verbose_name = '友情链接' verbose_name_plural = verbose_name ``` ### 轮播 博客首页不能全是文章啊,轮播什么的必须要有 ```python class Banner(models.Model): '''轮播图''' title = models.CharField('标题', max_length=50, default='') img = models.ImageField('轮播图', upload_to='banner/') link_url = models.URLField('图片链接', max_length=100) is_active = models.BooleanField('是否激活', default=False) def __str__(self): return self.title class Meta: verbose_name = '轮播图' verbose_name_plural = verbose_name ``` ### 模型设计完后,注册模型并同步到数据库中 ```python from django.contrib import admin from .models import Banner, Navigation, Category, Tag, Tui, Article, Link @admin.register(Article) class ArticleAdmin(admin.ModelAdmin): list_display = ('id', 'title', 'tui', 'user', 'views', 'comment_count', 'created_time') list_filter = ('tui', 'user', 'created_time') # 文章列表里显示想要显示的字段 list_per_page = 50 # 满50条数据就自动分页 ordering = ('-created_time',) # 后台数据列表排序方式 list_display_links = ('id', 'title') @admin.register(Banner) class BannerAdmin(admin.ModelAdmin): list_display = ('id', 'text_info', 'img', 'link_url', 'is_active') list_filter = ('text_info', 'img', 'link_url', 'is_active') @admin.register(Navigation) class NavigationAdmin(admin.ModelAdmin): list_display = ('id', 'name') list_filter = ('name',) @admin.register(Category) class CategoryAdmin(admin.ModelAdmin): list_display = ('id', 'name') list_filter = ('name',) @admin.register(Tag) class TagAdmin(admin.ModelAdmin): list_display = ('id', 'name') list_filter = ('name',) @admin.register(Tui) class TuiAdmin(admin.ModelAdmin): list_display = ('id', 'name') list_filter = ('name',) @admin.register(Link) class LinkAdmin(admin.ModelAdmin): list_display = ('id', 'name', 'link_url') list_filter = ('name', 'link_url') ``` 通过Pycharm的terminal执行命令 创建迁移脚本 `python manage.py makemigrations` 同步数据库`python manage.py migrate`",
    "作为一个开发者,每每看到别人的博客,有的人的博客特效特效酷炫屌炸天,有的记录着所碰到的问题的解决方案,有的有的...,我就想自己弄一个属于我自己的博客 ### 创建项目 我所使用的的开发工具是PyCharm,这个开发工具包含了所有功能,比较方便,就是运行起来比较吃内存,闲话不多说,开干! 使用PyCharm创建新的Django项目`djangoBlog` ![](/media/editor/create project_20190411150136409600.png) ### 创建项目目录结构 ![](/media/editor/desc_20190411151849799707.png) ### 创建app应用 使用命令`python manage.py startapp blog`创建名称为`blog`的应用 创建完`blog`应用后,它并没有进入我们创建的`apps`package包中,这时我们要自己手动把`blog`移动到`apps`package包中,记住,apps是一个package包,然后把鼠标放在`apps`包上,右键鼠标选择`Mark Directory as `-> `Sources Root` ### 注册app应用 修改`settings.py`文件 ```python INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'apps.blog' # 新增应用 ] ``` ### 修改settings.py设置 ```python LANGUAGE_CODE = 'zh-hans' # 后台中文显示 TIME_ZONE = 'Asia/Shanghai' # 设置中国时间 USE_I18N = True # 国际化,支持多种语言 USE_TZ = False # USE_TZ = True 表示UTC时间,False表示本地时间 # 设置文件上传路径 MEDIA_URL = '/media/' MEDIA_ROOT = os.path.join(BASE_DIR, 'media') ``` ### 修改数据库 django默认数据为`sqlite`数据库,要修改为`mysql`数据库 ```python # 默认数据库 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': 'db', } } ``` 修改为MySQL数据库: ```python DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'your database', 'USER': 'your username', 'PASSWORD': 'your password', 'PORT': 3306 } } ``` 数据库修改为MySQL,会报错没有驱动,这时我们需要安装一个名为`pymysql`的包,执行命令`pip install pymysql`,然后在`settings.py`中添加 ```python import pymysql pymysql.install_as_MySQLdb() ``` ### 迁移数据库 执行命令`python manage.py makemigrations`创建迁移脚本,然后执行命令`python manage.py migrate`迁移数据",
    "刚开始玩django的时候，我们都会使用django内置的sqlite数据库，但当我们存入得数据多了之后，想切换成mysql数据库，但又不想再次浪费时间去重新写入数据库时就需要知道这些命令了！ ### 迁移数据 我们很多时候刚开始开发django项目的时候都会使用sqlite数据库，到后面会切换成mysql数据库，又不想数据丢失，这时我们就可以用使用django的导入导出命令来迁移数据，避免了很多不必要的麻烦 ### 导出sqlite数据库 首先要你的数据库确实是sqlite并且存在，在settings.py中 ```python DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ``` ### 然后导出 ```shell python manage.py dumpdata > data.json ``` ### 导入mysql数据库 这里导入之前要先创建数据库名为`website`的数据库，并修改数据库引擎 ```mysql # 创建数据库 CREATE DATABASE `website` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; ``` ```python DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'your database', 'USER': 'your username', 'PASSWORD': 'your password', 'PORT': 3306 } } ``` ### 执行命令导入数据库 `python manage.py loaddata data.json` ###最后大功告成！ <img src='/media/upimg/20190324231019_20190327150058_673.png' title='success' alt='20190324231019.png'/>",
    "现有一个django项目时，要求django版本1.11，真实环境的版本是2.0，如果使用系统环境 会导致出现兼容问题，这个时候就需要虚拟环境，virtualenv就是用来创建这个项目运行的开发环境 virtualenv是一个创建隔绝的Python环境的库。virtualenv创建的虚拟环境和原本安装的环境相互独立，不会影响，而virtualenvwrapper 是用来管理virtualenv创建的虚拟环境,是一个基于virtualenv之上的工具，它将所有的虚拟环境统一进行管理. ### 安装virtualenv 使用`pip`或`pip3`命令安装 ```python # 安装虚拟环境工具 pip install virtualenv pip3 install virtualenv ``` 安装完成后就可以使用virtualenv的命令创建虚拟环境了，首先，我们进入要创建虚拟环境的文件夹中，创建一个名叫venv的虚拟环境，使用命令 `virtualenv venv` 创建是在你当前所在文件夹创建一个叫venv的环境 创建完成后会命令行前面会多一个(venv),表示环境创建完成,并自动进入到了venv虚拟环境中了,在这个环境中安装的包和本身系统的环境完全独立,互不影响 ### 退出虚拟环境 `deactivate`执行这个指令就行 ### 进入虚拟环境 当我们退出后在想进入却发现怎么进入呢,之前创建的时候是自动进入的,现在总不可能在创建吧!这时就需要进入虚拟环境的指令了,找到你创建虚拟环境的文件夹,执行命令 ```Shell # linux执行这行命令 source venv/bin/activate # windows 执行这两行命令 cd venv/Scripts; # 切换到虚拟环境下venv/Scripts文件夹中 activate # 启动虚拟环境 ``` 但这样创建有个不好的问题,那就是当你的项目环境创建多了之后,有可能你自己也不知道有多少个,哪些放在了哪里,你需要一个管理虚拟环境的包管理器, `virtualenvwrapper`这时就闪亮登场了 ### 安虚拟环境包管理器(这里我使用的linux系统) ```python # 执行命令sudo安装 sudo pip install virtualenvwrapper ``` ```python # 找到配置文件,一般在`/home/honey/.bashrc`文件中 export WORKON_HOME=$HOME/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 source /usr/local/bin/virtualenvwrapper.sh # 如果出现报错,说明你执行命令安装的时候因为权限问题,并不是执行的sudo安装 # 安装后的位置发生了改变,导致命令找不到启动脚本 # 只需要修改最后一行代码 source /usr/.local/bin/virtualenvwrapper.sh # 当然你也可以写在后重新sudo安装 pip uninstall virtualenvwwrapper sudo install virtualenvwrapper ``` 创建完成后就可以使用virtualenvwrapper管理虚拟环境了 #### 包管理器常用命令 ```python mkvirtualenv venv # 创建虚拟环境 rmvirtualenv venv # 删除虚拟环境 lsvirtualenv # 列出所有的虚拟环境(不是使用virtuapenvwrapper创建的虚拟环境除外) workon venv # 进入虚拟环境 deactivate # 退出虚拟环境 ```",
    "每次开发和生产部署，都要频繁的去修改DEBUG ### 动态修改DEBUG模式 想法借鉴[杨士航博客](http://yshblog.com/blog/26 '杨士航博客'){:trget=_blank},我按照他的idea配置了,但却出现得到的ip为127.0.0.1,导致DEBUG后来百度才知道可能是修改了`/etc/hosts`文件 ```python import socket if socket.gethostbyname(socket.gethostname())[:3]=='192': DEBUG = True else: DEBUG = False ALLOWED_HOSTS = ['www.zhangwurui.com'] ``` 我用的是UDP套接字连接获取ip地址 ```python s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # AF_INET表示ipv4 SOCK_DGRAM表示UDP套接字 s.connect(('8.8.8.8', 80)) # 连接 ip,port = s.getsockname() # 这里的ip就是真实ip了 ```",
    "git命令之前也了解了很长一段时间了,常用的几个命令倒是很熟悉,用的比较少的命令却总是忘记,这几天部署网站,又重新学习了一遍 使用git已两三月了，最常用的几个命令倒是很熟悉，用的比较少的命令很是记不清，要多多探索这些命令，首先要有个帐号为所欲为，接下来开始正题 ### 生成SSH ```git ssh-keygen -t ras -C 'your email' // 生成后会要你输入啥的,不用输入,直接回车,直到完成 ``` ### 设置用户名 ```git git config --global user.name 'your username' git config --global user.email 'your email' ``` ### 初始化当前目录的项目 ```git git init # 在该目录下新建一个后缀为md的文件，然后查看，将修改添加到暂存区 touch README.md git add . # 将工作区所有修改添加到暂存区 git add filename # 将指定文件添加到暂存区 git status # 列出变更文件 # 将暂存区修改添加到本地仓库 git commit -m '备注信息' # 创建仓库，将本地仓库改动push到远程仓库 git remote add origin git push -u origin master ``` ### 每次push都要输入用户名和密码，原因是https方式 push,如何解决呢? ```git git remote rm origin // 移除仓库 git remote add origin git@github.com:gitname/test.git // 重新添加 ``` 以后就不用再输入用户名和密码了 ### 从远程clone项目 ```git git clone url // 放弃暂存区修改 git checkout -- filename // 放弃暂存区修改（修改不在） git rm --cached filename // 放弃add（修改还在，但产生一条delete记录） git reset HEAD filename // 同上（没有delete记录） git stash // 暂时放弃未提交的修改git stash pop // 恢复 ``` ### 分支操作 ```git git branch // 查看分支 git branch -r //所有本地分支 git branch -a //所有远程分支 git branch branchName // 留在当前分支 git checkout -b branchName //创建并切换分支 git branch --set-upstream-to=<remote>/branchName // 建立本地分支与远程分支的追踪关系 git branch --track branchName [remote branch] // 新建一个分支，并与远程建立追踪关系 git checkout branchName // 切到指定分支 /*分支合并*/ git pull origin branch // 取回远程更新并与本地分支合并 git fetch origin branch // 取回远程更新 git merge branch // 合并指定分支到当前分支(产生提交记录) git rebase branch // 合并指定分支到当前分支(不产生提交记录，比较适合有强迫症的) git cherry-pick commitId // 将与commitId对应的提交合进当前分支 ```",
    "Sitemap可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站 在`django`中添加`sitemap`,首先要把相关APP应用安装到`settings.py`中的`INSTALL_APP`中,这里无需使用`pip`,`django`从1.6开始，默认情况下不启用`site`框架,所以我们只需要启用即可~ ```django INSTALL_APP = [ ''', 'django.contrib.sites', 'django.contrib.sitemaps', ] SITE_ID = 1 ``` 这里我还添加了SITE_ID= 1,如过不设置可能会登录后台报错,表示指定当前站点 然后登录后台,会多了一个站点(SITE) ![站点](/media/editor/site_20190424150435619391.png '站点') 修改为你自己的域名和名称,如果你是本地开发域名为设置为127.0.0.1:8000 ### 添加sitemap功能 在项目文件夹下新增`sitemap.py` ```django from django.contrib.sitemaps import Sitemap from apps.blog.models import Article, Category, Tag from django.urls import reverse class ArticleSiteMap(Sitemap): '''changefreq 更新频率 priority 相对于其它页面的优先权''' changefreq = 'monthly' priority = '0.6' def items(self): return Article.objects.all() def lastmod(self, obj): '''上次修改时间''' return obj.modified_time def location(self, obj): '''可选.返回每个对象的绝对路径.如果对象有get_absolute_url()方法,可以省略location''' return reverse('blog:detail', kwargs={'pk':obj.id}) class CategorySiteMap(Sitemap): changefreq = 'Weekly' priority = '0.6' def items(self): return Category.objects.all() def lastmod(self, obj): return obj.modified_time def location(self, obj): '''可选.返回每个对象的绝对路径.如果对象有get_absolute_url()方法,可以省略location''' return reverse('blog:category', kwargs={'pk':obj.id}) class TagSiteMap(Sitemap): ''' changefreq 更新频率 priority 相对于其它页面的优先权 ''' changefreq = 'Weekly' priority = '0.3' def items(self): return Tag.objects.all() def lastmod(self, obj): return obj.modified_time def location(self, obj): '''可选.返回每个对象的绝对路径.如果对象有get_absolute_url()方法,可以省略location''' return reverse('blog:tags', kwargs={'pk': obj.id}) ``` ### urls.py增加 ```django from DjangoBlog.sitemap import ArticleSiteMap, CategorySiteMap, TagSiteMap sitemaps = { 'blog': ArticleSiteMap, 'Category': CategorySiteMap, 'Tag': TagSiteMap, } re_path(r'^sitemap\\.xml$', sitemap, {'sitemaps': sitemaps}, name='django.contrib.sitemaps.views.sitemap'), ``` 浏览器中访问: http://127.0.0.1:8000/sitemap.xml",
    "ES6标准新增了一种新的函数：Arrow Function（箭头函数）, 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数 在了解箭头函数前,我们先看一个常规例子: ```javascript function fn(){ console.log('hello~') } fn() // hello~ ``` 再来看看箭头函数如何表示的 ```javascript fn = () => { console.log('hello~') } fn() // hello~ ``` 是不是简单很多,再来看看这条,这种只适用于只有一条语句时,可以省略大括号`{}` ```javascript fn = () => console.log('hello~') fn() // hello~ ``` 如果我们需要传第一个和多个参数呢? ```javascript // 只有一个参数 fn = (a) => a + 2 // 只有一个参数时还可以省略小括号 fn =a => a + 2 // 多个参数 fn = (a,b,c) a + b + c ``` 我们在来看看这个例子: ```javascript const Person = { name: 'Superficial', age:23, 'get': function() { setInterval(function (){ console.log(this.age) }) } } Person.get() // undefined ``` 结果是不是出乎意料,没错,相信自己的眼睛,你没看错,这是由于[this指向](https://bonsaiden.github.io/JavaScript-Garden/zh/#function.this 'this指向'){:target=_blank}的问题 以前的写法是在函数中把this绑定到变量上 ```javascript const Person = { name: 'Superficial', age:23, 'get': function() { let that = this; setInterval(function (){ console.log(that.age) }) } } Person.get() // 23 ``` 查看详细[箭头函数的语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Syntax '箭头函数'){:target=_blank}相关内容",
    "ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发布。涵盖了 ES2015、ES2016、ES2017 等等，ES6 主要是为了解决 ES5 的先天不足。 ### var 通过`var`定义的全局变量,会变量提升,作用域是全局的,可以重复声明,不会出现报错,也没有提示. ```javascript console.log(a) // undefined var a = 1; var a = 2; console.log(a) // 2 ``` 当多人协作开发时,修改某一块的代码时,有可能会造成重复声明了相同的变量,导致我们所需要的数据被覆盖,而我们可能需要好长时间去检查才会找到问题的所在,这时我们有需要`let` ### let 定义变量,和var一样,不过一般用于块级作用域,也就是花括号{},ES6推荐在函数中使用let,而不是var ```javascript let a = 1; let a = 5; console.log(a); // 会报错(a已经被声明了) Identifier 'a' has already been declared { let b = 1; } console.log(b); // ReferenceError: b is not defined ``` 不会变量提升 ```javascript console.log(a); // ReferenceError: a is not defined let a = 1; let b; console.log(b) // undefined ``` 有5个`li`标签,通过点击事件获取`li`的索引 ```javascript for(var i = 0; i < 5; i++){ aLi[i].i = i; aLi[i].onclick = function () { alert(this.i) // 0 1 2 3 4 } } ``` 我们会发现所有`li`的索引都是最后一个`i`值,这是由于JS引擎执行是按照从左到右的顺序,先执行了`for`循环,同时将循环中的代码也一并执行了,这个时候`i`的值已经成了最后一个,然后才给`click`事件绑定的 解决办法: 1. 使用闭包 ```javascript let aLi = document.getElementsByTagName('li'); for(var i = 0; i < 5; i++){ (function (i){ aLi[i].onclick = function () { alert(i) // 0 1 2 3 4 } })(i) } ``` 2. 使用自定义属性 ```javascript for(var i = 0; i < 5; i++){ aLi[i].i = i; // 给标签添加一个自定义属性 aLi[i].onclick = function () { alert(this.i) // 0 1 2 3 4 // 这里this.i指的是自定义属性的i } } ``` 但这样终究是让我们多写了几行代码,我们的宗旨是能少写就少写,能不写就不写,这里我们把`var`换成`let`就解决了,是不是简单很多 ```javascript for(let i = 0; i < 5; i++){ aLi[i].onclick = function () { alert(i) // 0 1 2 3 4 } } ``` ### const 通过`const`定义的变量不可以修改,而且必须初始化 ```javascript const TYPE; // 会报错,必须赋值完成初始化 Missing initializer in const declaration const TYPE = 1; TYPE = 2; // 也会报错,定义的常量不可以修改 Assignment to constant variable. ``` 总结: `let`声明的变量不具备变量提升;`let` 和 `const` 声明只在最靠近的一个块中（花括号内）有效;使用常量`const` 声明时必须被赋值;定义常量时使用大写变量表示,符合规范",
    "在网上看到这样一个问题,你能想出几种方案,我们很容易就会想到float, position,flex,然后绞尽脑汁再也想不出来了,现在记录下来 ### 第一种方案: float ```html <section class='layout float'> <div class='left'></div> <div class='right'></div> <div class='center'> <h1>浮动解决方案</h1> </div> </section> ``` ```css .left { width: 300px; background-color: red; } .right { width: 300px; background-color: blue; } .float .left { float: left; } .float .right { float: right; } section.layout div { min-height: 100px; } .center { background-color: yellow; } ``` ### 第二种方案: position ```html <section class='layout position'> <div class='right'></div> <div class='left'></div> <div class='center'> <h1>绝对定位解决方案</h1> </div> </section> ``` ```css section.position { position: relative; } section.position .left { position: absolute; left: 0; } section.position .right { position: absolute; right: 0; } section.position .center { margin-left: 300px; margin-right: 300px; } ```",
    "有些时候我们写一些文本文字时,需要处理超出的问题,这时我们需要用到css3的属性来实现文本超出隐藏 ### 要实现文本超出隐藏,我们要先了解这些css属性 ### overflow | 值 | 描述 | | :------------: | :------------: | | visible | 默认值.超出后可见 | | hidden | 超出后隐藏 | | scroll | 超出后会显示滚动条 | | auto | 如果内容超出,则会出现滚动条 | | inherit | 继承父类的overflow属性 | ### text-overflow | 值 | 描述 | | :------------: | :------------: | | clip | 修剪文本 | | elipsis | 用省略号代替修剪的文本 | | string | 用给定字符串代替修剪的文本 | ### white-space | 值 | 描述 | | :------------: | :------------: | | normal | 默认.空白被浏览器忽略 | | nowrap | 文本不会换行 | | inherit | 继承父元素 white-space 属性 | ### 单行超出隐藏 ```css overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ``` ![](/media/upimg/text-overflow_20190330005419_840.png) ### 多行文本超出隐藏 ```css /* 适用范围：因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； */ display: -webkit-box; /* 必须结合的属性，将对象作为弹性伸缩盒子模型显示。 */ -webkit-box-orient: vertical; /* 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式 */ -webkit-line-clamp: 3; /* 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性 */ overflow: hidden; ``` ![](/media/upimg/text-overflow-clamp_20190330005725_841.png) 该文章属性借鉴自[w3school](http://www.w3school.com.cn/ 'w3school'){:traget=_blank}可自行到其网站查看",
    "当我们用CSS写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，这时我们就需要使用一些预处理器来进行CSS开发,Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline import)等高级功能,使我们更好地组织管理样式文件，以及更高效地开发项目. ### 安装Ruby以及Sass 在Pycharm中想要使用Scss,Scss是基于Ruby的,首先,我们需要安装Ruby,可以去[官网](https://rubyinstaller.org/downloads/ '官网'){:target=_blank}下载,安装比较简单,一直next即可,进入`cmd`,执行命令`ruby -v`查看`ruby`是否有ruby版本,如果没有重新安装,安装完成后还要安装`sass`,在`cmd`终端执行命令`gem install sass`,等待安装完成! ### 在Pycharm中配置file watcher 进入到`File -> Settings -> Tools -> File Watchers`点击`+`添加`SCSS` ```Scss Name: SCSS File type: SCSS Style Sheet Scope: Project Program: 你安装的sass文件 Arguments: --style expanded --no-cache --update $FilePath$ Output paths to refresh: $FileName$:$ProjectFileDir$/css/$FileNameWithoutExtension$.css ``` 这样你写了`SCSS`文件保存后就会自动编译了~",
    "### viewport 视口 ```html <meta name='viewport' content='width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no' /> width=device-width(设备宽度) initial-scale=1.0(缩放比例) minimum-scale=1.0(允许用户最小缩放比例) maximum-scale=1.0(允许用户最大缩放比例) user-scalable=no(yes/no,是否允许手动缩放) ``` [文章详细地址](https://www.cnblogs.com/2050/p/3877280.html '文章详细地址'){:target='_blank'"
    ],
    "article_summary": [
    "我们都知道,浏览器自带的滚动条样式太丑,要美化滚动条就需要自定义滚动条样式,可以用js来模拟滚动条,但这样要大量的兼容处理,比较麻烦,CSS3也可以实现自定义滚动条,好像只支持webkit内核的浏览器 /*滚动条整体样式*/ ::-webkit-scrollbar { width: 6px; height: 1px; } /*滚动条滑块*/ ::-webkit-scrollbar-thu",
    "重定向 分为永久性重定向和暂时性重定向 永久性重定向:多用于旧网址被废弃,要转到一个新网址确保用户可以访问.http状态码:301,比如www.jingdong.com会重定向到www.jd.com 暂时性重定向:页面的暂时新跳转,比如用户访问一个需要权限的网址,如果用户没有登录,将重定向到登录页面.http状态码:302 flask中使用重定向: flask中有个函数redirect,可以重定向",
    "前面的学习中,我们都是通过url进入的与之相对应的视图函数,现在有一个问题,如果我们知道了视图函数，要怎么找到url呢？这时候我们就需要url_for反转函数了。它通过把视图函数反转成路由地址 url_for的基本使用 from flask import url_for @app.route(&quot;/&quot;) def index(): return &quot;Hello Wo",
    "URL与视图函数的映射 url与视图函数的映射是通过@app.route()装饰器实现的,而route中的参数表示路由路径 路由 @app.route(&quot;/&quot;) def hello_world(): return &quot;Hello World!&quot; 这是项目自带的根路由,访问/路由时,页面会返回Hello World! 如果要访问文章列表只需要在写一个",
    "设置调试模式的原因 如果开启了DEBUG模式,在代码中如果抛出异常,在浏览器页面中可以看到具体的错误信息,方便调试 如果修改了代码只需要保存后,flask会自动重新加载程序,而不用重新运行 当我们运行新创建的flask项目时,控制台打印: * Environment: production WARNING: This is a development server. Do ",
    "安装flask 如果使用的windows首先要安装python环境 pip install flask 这里我使用的是PyCharm Professional直接创建创建一个名为demo的flask项目,这会花费一点时间,pycharm会帮我们安装flask所必须要的包,等待创建完成即可,创建完成后目录会会有三个文件夹, static, templates,venv,还有一个app.py文件 ",
    "当select值为对象类型时，option要拿到指定的value,就需要提供一个value-key作为唯一性标识,option的value不需要绑定指定的value,只需要绑定对象 &lt;template&gt; &lt;el-select v-model=&quot;postForm.tags&quot; value-key=&quot;name&quot; mul",
    "在我初步使用celery时,出现了问题,在这记录自己碰到的问题, 我所使用的的开发环境 系统, 编辑工具, 1. windows 764位 2. PyCharm 2018.3.2 (Professional Edition) 3. Celery 4.3.0 执行简单的任务队列时报错 Traceback (most recent call last): File &quot;d:\\python3",
    "当一个用户在看你的博客文章时，他（她）还想看看相关类型的文章，还要排除当前文章，并且不能包含当前文章，如何实现呢? 这里我用到了django的tamplate_tags,如果没有了解过模板标签,请到官网自行了解 在blog应用下创建tamplate_tags包(不是py文件,包含一个__init__.py) from django import template from blog.models ",
    "确认MySQL环境安装mysql -V,出现MySQL版本表示已经安装,出现Not Found表示没有安装,如果没有安装执行安装命令 sudo apt-get install mysql-server mysql-client 还需要安装 sudo apt-get install libmysqlclient-dev python3-dev 然后 pip install mysqlclient",
    "VMWare安装VMWare Tools 作为一个开发者，linux系统是必须要会使用的，我的电脑是windows，那么如何在电脑上安装linux系统呢？ 这里就需要一个虚拟化软件，我使用的是VMWare，通过它来创建linux环境，linux系统我使用的是乌班图桌面版，安装完系统后，使用过程中，发现系统卡顿，这时我们就需要安装VMWare Tools来解决 首先启动Ubuntu系统，然后如下",
    "当我们写了一遍文章后如何让百度蜘蛛知道并来爬取我们的文章呢? 这里就需要我们主动提交数据链接到百度资源了 推送数据到百度站点 在Article模型中新增push方法 def push(self): &quot;&quot;&quot;推送到百度&quot;&quot;&quot; if self.status == &quot;p&quot;: # 当状态为发表时才",
    "django默认后台登录只能通过用户名登录,如果想要通过用户名或者邮箱登录,那就需要自定义后台验证了 在自定义的用户模型(Accounts)中新建backends.py from django.contrib.auth.backends import ModelBackend from django.db.models import Q from django.contrib.auth impor",
    "在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们不再使用Session认证机制，而使用Json Web Token认证机制。 安装django-rest-framework pip install djangorestframework djangorestframework-jwt 在settings.py- -&gt; INSTALL-APP中添加 INSTAL",
    "Grid 布局是 CSS 中最强大的布局系统。与 flexbox 的一维布局系统不同，Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于 父元素 (成为 Grid Container 网格容器)和其 子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid(网格) 布局。 Gird通过将元素的父级设置display: grid,来声明这是一",
    "django的强大就在于他自带后台管理系统,当然界面嘛,比较不符合我的审美,未来会考虑自定义后台界面,现阶段暂时先不管 创建超超级管理员并登陆后台 执行命令python manage.py createsuperuser 这时会要求输入用户名,邮箱,密码,以及确认密码,依次输入即可,当然,如果你的大密码输入过于简单,可能会报错,密码设置相对复杂一点!我们就可以登录后台了 运行python mana",
    "一个网站,最重要的部分就是数据库的设计,在django就需要设计数据库模型,模型当中每一个属性都对应一个数据库表的字段 我的博客灵感来自于轩陌的博客,他的博客页面好看,所以参考他的多一些. 在创建的blogApp应用中打开models.py 导航栏以及分类模型 创建导航栏,导航栏的设计我是这样设计的,一个一级栏目下有零个或多个二级栏目,涉及到了一对多,当然如果对一对多不熟悉的话可以去看djan",
    "作为一个开发者,每每看到别人的博客,有的人的博客特效特效酷炫屌炸天,有的记录着所碰到的问题的解决方案,有的有的...,我就想自己弄一个属于我自己的博客 创建项目 我所使用的的开发工具是PyCharm,这个开发工具包含了所有功能,比较方便,就是运行起来比较吃内存,闲话不多说,开干! 使用PyCharm创建新的Django项目djangoBlog 创建项目目录结构 创建app应用 使用命令pyth",
    "刚开始玩django的时候，我们都会使用django内置的sqlite数据库，但当我们存入得数据多了之后，想切换成mysql数据库，但又不想再次浪费时间去重新写入数据库时就需要知道这些命令了！ 迁移数据 我们很多时候刚开始开发django项目的时候都会使用sqlite数据库，到后面会切换成mysql数据库，又不想数据丢失，这时我们就可以用使用django的导入导出命令来迁移数据，避免了很多不必要的",
    "现有一个django项目时，要求django版本1.11，真实环境的版本是2.0，如果使用系统环境 会导致出现兼容问题，这个时候就需要虚拟环境，virtualenv就是用来创建这个项目运行的开发环境 virtualenv是一个创建隔绝的Python环境的库。virtualenv创建的虚拟环境和原本安装的环境相互独立，不会影响，而virtualenvwrapper 是用来管理virtualenv创建",
    "每次开发和生产部署，都要频繁的去修改DEBUG 动态修改DEBUG模式 想法借鉴杨士航博客,我按照他的idea配置了,但却出现得到的ip为127.0.0.1,导致DEBUG后来百度才知道可能是修改了/etc/hosts文件 import socket if socket.gethostbyname(socket.gethostname())[:3]==&quot;192&quot;: DE",
    "git命令之前也了解了很长一段时间了,常用的几个命令倒是很熟悉,用的比较少的命令却总是忘记,这几天部署网站,又重新学习了一遍 使用git已两三月了，最常用的几个命令倒是很熟悉，用的比较少的命令很是记不清，要多多探索这些命令，首先要有个帐号为所欲为，接下来开始正题 生成SSH ssh-keygen -t ras -C &quot;your email&quot; // 生成后会要你输入啥的,不用输入",
    "Sitemap可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站 在django中添加sitemap,首先要把相关APP应用安装到settings.py中的INSTALL_APP中,这",
    "ES6标准新增了一种新的函数：Arrow Function（箭头函数）, 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数 在了解箭头函数前,我们先看一个常规例子: function fn(){ console.log(&quot;hello~&",
    "ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发布。涵盖了 ES2015、ES2016、ES2017 等等，ES6 主要是为了解决 ES5 的先天不足。 var 通过var定义的全局变量,会变量提升,作用域是全局的,可以重复声明,不会出现报错,也没有提示. console.log(a) // undefined var a = 1; v",
    "在网上看到这样一个问题,你能想出几种方案,我们很容易就会想到float, position,flex,然后绞尽脑汁再也想不出来了,现在记录下来 第一种方案: float &lt;section class=&quot;layout float&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div clas",
    "有些时候我们写一些文本文字时,需要处理超出的问题,这时我们需要用到css3的属性来实现文本超出隐藏 要实现文本超出隐藏,我们要先了解这些css属性 overflow 值 描述 visible 默认值.超出后可见 hidden 超出后隐藏 scroll 超出后会显示滚动条 auto 如果内容超出,则会出现滚动条 inherit 继承父类的overflow属性 te",
    "当我们用CSS写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，这时我们就需要使用一些预处理器来进行CSS开发,Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline import)等高级功能,使我们更好地组织管理样式文件，以及更高效地开发项目. 安装Ru",
    "viewport 视口 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; width=device-width(设备宽度) initial-sca"
    ],

    "article_views": [21,17,3,10,6,24,6,29,8,0,12,18,19,30,36,127,300,400,124,105,75,49,65,246,71,147,247,388,209],
    "article_created_time": [
    "2019-06-09T12:55:32.048",
    "2019-05-29T09:59:00.161",
    "2019-05-28T05:16:26.041",
    "2019-05-27T11:13:32.619",
    "2019-05-26T01:25:53.735",
    "2019-05-25T13:44:31.116",
    "2019-05-23T23:47:51.950",
    "2019-05-14T00:35:08.407",
    "2019-05-12T04:09:01.373",
    "2019-05-11T02:44:43.071",
    "2019-05-10T18:58:39.654",
    "2019-05-03T18:47:17.250",
    "2019-05-03T15:37:54.676",
    "2019-05-03T13:26:35.347",
    "2019-04-29T18:08:21.200",
    "2019-04-29T13:31:35.692",
    "2019-04-29T13:30:56.735",
    "2019-04-29T13:30:12.931",
    "2019-04-27T23:49:33.055",
    "2019-04-27T23:48:43.735",
    "2019-04-27T23:47:12.470",
    "2019-04-27T23:45:32.121",
    "2019-04-27T23:42:35.398",
    "2019-04-27T23:40:42.130",
    "2019-04-27T23:38:55.291",
    "2019-04-27T23:37:18.808",
    "2019-04-27T23:35:19.364",
    "2019-04-26T17:13:33.021",
    "2019-04-25T17:26:04.694"
    ],
    "article_updated_time": [
    "2019-06-11T12:16:30.714",
    "2019-06-03T10:57:10.749",
    "2019-06-03T10:57:10.762",
    "2019-06-03T10:57:10.773",
    "2019-06-03T10:57:10.784",
    "2019-06-03T10:57:10.793",
    "2019-06-03T10:57:10.800",
    "2019-06-03T10:57:10.810",
    "2019-06-03T10:57:10.818",
    "2019-06-03T10:57:10.827",
    "2019-06-03T10:57:10.835",
    "2019-06-03T10:57:10.843",
    "2019-06-03T10:57:10.855",
    "2019-06-03T10:57:10.865",
    "2019-06-03T10:57:10.874",
    "2019-06-03T10:57:10.883",
    "2019-06-03T10:57:10.898",
    "2019-06-03T10:57:10.919",
    "2019-06-03T10:57:10.933",
    "2019-06-03T10:57:10.945",
    "2019-06-03T10:57:10.954",
    "2019-06-03T10:57:10.964",
    "2019-06-03T10:57:10.976",
    "2019-06-03T10:57:10.986",
    "2019-06-03T10:57:10.998",
    "2019-06-03T10:57:11.008",
    "2019-06-03T10:57:11.021",
    "2019-06-03T10:57:11.031",
    "2019-06-03T10:57:11.042"
    ]
}